<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pycelp.ion API documentation</title>
<meta name="description" content="This module contains the Ion class for pycelp." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycelp.ion</code></h1>
</header>
<section id="section-intro">
<p>This module contains the Ion class for pycelp.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
This module contains the Ion class for pycelp.
&#39;&#39;&#39;

import numpy as np
from pycelp.chianti import *
from pycelp.collisions import *
from pycelp.non_dipoles import *
from pycelp.dipoles import *
from pycelp.emissionLine import * 
import pycelp.util as util

class Ion:
    &#34;&#34;&#34;
    The ion object is the primary class used by pycelp for calculations of the
    polarized emission for a particular transition. Upon initialization, an Ion
    object loads all necessary atomic data from the CHIANTI database and
    pre-calculates all pre-factors and static terms of the statistical
    equilibrium rate equations.

    Parameters
    ----------
    ion_name : str
        Name of ion (e.g., &#39;fe_13&#39;)
    nlevels:  int (default = None)
        Number of energy levels to include (default is all)
    ioneqFile : str (default = None)
        Ionization equilibrium filename (defaults to Chianti default file)
    abundFile : str (default = None)
        Abundance filename (defaults to sun_photospheric_2009_asplund.abund)
    all_ks : bool (default = False)
        Flag to include all multipole order Ks in the calculation
        The default is to include only the even values of K for the no
        coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.

    References
    ----------
    Egidio Landi Degl’innocenti and Marco Landolfi (2004)
    &#34;Polarization in Spectral Lines&#34;
    &lt;https://link.springer.com/book/10.1007/1-4020-2415-0&gt;

    &#34;&#34;&#34;

    def __init__(self, ion_name,nlevels=None,ioneqFile=None,
                abundFile=None,all_ks = False):

        ## READ CHIANTI ATOMIC DATA
        elvl_data    = elvlcRead(ion_name)   ## ENERGY LEVEL DATA
        wgfa_data    = wgfaRead(ion_name)    ## RADIATIVE TRANSITION DATA
        scups_data   = scupsRead(ion_name)   ## ELECTRON COLLISIONAL DATA
        splups_data  = splupsRead(ion_name)  ## PROTON COLLISIONAL DATA
        abund_data   = abundRead(&#39;temp&#39;)     ## not selectable yet
        ioneq_data   = ioneqRead(&#39;temp&#39;)     ## not selectable yet

        ### REDUCE NUMBER OF CONSIDERED LEVELS
        if nlevels != None:
            elvl_data  = limit_levels(elvl_data,nlevels,type = &#39;elvl&#39;)
            wgfa_data  = limit_levels(wgfa_data,nlevels,type = &#39;wgfa&#39;)
            scups_data = limit_levels(scups_data,nlevels,type = &#39;scups&#39;)
            splups_data = limit_levels(splups_data,nlevels,type = &#39;splups&#39;)

        nlevels     = len(elvl_data[&#39;energy&#39;])

        ### DERIVE NECESSARY ATOMIC PARAMETERS
        element, ion_stage = ion_name.split(&#39;_&#39;)
        ion_stage     = int(ion_stage)
        ionZ          = getIonZ(ion_name)
        atomicWeight  = getAtomicWeight(element)
        element_abund = abund_data[&#39;abund_val&#39;][np.where(abund_data[&#39;abund_z&#39;] == ionZ)][0]
        eq_logtemp    = np.copy(ioneq_data[&#39;temp&#39;])
        eq_frac       = np.copy(ioneq_data[&#39;ionfrac&#39;][:,ionZ-1,ion_stage-1]).clip(1.e-30)
        eq_logfrac    = np.log10(eq_frac)
        yderiv2       = util.new_second_derivative(eq_logtemp,eq_logfrac,1e100,1e100)
        qnj           = elvl_data[&#39;j&#39;]

        ######### SETUP INDICES OF THE SEE MATRIX AND GET WEIGHTS
        see_neq,see_index,see_lev,see_k,see_dk = util.setupSEE(qnj,all_ks=all_ks)
        weight = np.zeros(see_neq)
        weight[see_k == 0] =  np.sqrt((2.*qnj[see_lev[see_k == 0]]+1))

        ######### ELECTRON COLLISION RATE INITIALIZATION CALCULATIONS
        ## precalculate the spline interpolations
        scups_data[&#39;yd2&#39;] = getSecondDerivatives(scups_data[&#39;bt_t&#39;],scups_data[&#39;bt_upsilon&#39;],scups_data[&#39;n_t&#39;])
        ettype = util.get_eTransType(elvl_data,scups_data)
        elowlev = scups_data[&#39;lower_level_index&#39;]-1
        eupplev = scups_data[&#39;upper_level_index&#39;]-1
        print(&#39; setting up electron collision rate factors&#39;)
        ciK,ciK_indx,csK,csK_indx = setup_ecoll(elowlev,eupplev,ettype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### PROTON COLLISION RATE INITIALIZATION CALCULATIONS
        splups_data[&#39;yd2&#39;] = getSecondDerivatives(splups_data[&#39;bt_t&#39;],splups_data[&#39;bt_upsilon&#39;],splups_data[&#39;n_t&#39;])
        plowlev = splups_data[&#39;lower_level_index&#39;]-1
        pupplev = splups_data[&#39;upper_level_index&#39;]-1
        pttype = np.zeros(len(plowlev)) - 1
        print(&#39; setting up proton  collision rate factors&#39;)
        ciKp,ciKp_indx,csKp,csKp_indx = setup_ecoll(plowlev,pupplev,pttype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### RADIATIVE RATES INITIALIZATION CALCULATIONS

        rupplev = wgfa_data[&#39;upper_level_index&#39;]-1
        rlowlev = wgfa_data[&#39;lower_level_index&#39;]-1
        gup    = 2*qnj[rupplev]+1
        glo    = 2*qnj[rlowlev]+1
        alamb  = 1.e8 / (elvl_data[&#39;energy&#39;][rupplev] - elvl_data[&#39;energy&#39;][rlowlev])
        a_up2low = wgfa_data[&#39;A_einstein&#39;]
        hh = 6.626176e-27  ## ergs sec (planck&#39;s constant);
        cc = 2.99792458e10 ## cm s^-1 (speed of light)
        b_up2low = (alamb**3)/2./hh/cc/1.e24*a_up2low
        b_low2up = gup/glo*b_up2low
        nrad = len(rlowlev)

        wv_air = util.vac2air(alamb)

        ### DERIVE D and E coefficients
        ss,ll,jj = elvl_data[&#39;s&#39;],elvl_data[&#39;l&#39;],elvl_data[&#39;j&#39;]
        landeg = util.calcLande(jj,ss,ll)
        Jupp,Jlow = jj[rupplev],jj[rlowlev]
        gupp,glow = landeg[rupplev],landeg[rlowlev]
        Dcoeff = util.getDcoeff(Jupp,Jlow)
        Ecoeff = util.getEcoeff(Jupp,Jlow,gupp,glow)
        geff = 0.5*(glow+gupp) + 0.25 * (glow-gupp) * (Jlow*(Jlow+1.) - Jupp*(Jupp+1.))
        
        ## --&gt; Non-dipoles
        print(&#39; setting up non-dipole radiative rate factors&#39;)
        tnD,tnD_indx,nonD_spon= setup_nonDipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,
                                                b_up2low,see_index,see_lev,see_k,see_dk)

        ## ---&gt; Dipoles
        print(&#39; setting up dipole radiative rate factors&#39;)
        tD,tD_indx,Dmat_spon = setup_Dipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,b_up2low,see_index,see_lev,see_k,see_dk)

        #################################################
        ## put into instance information
        self.ion_name = ion_name
        self.all_ks = all_ks
        ########################
        self.nlevels = nlevels
        self.elvl_data    = elvl_data
        self.landeg       = landeg
        self.wgfa_data    = wgfa_data
        self.scups_data   = scups_data
        self.splups_data  = splups_data
        self.abund_data   = abund_data
        self.ioneq_data   = ioneq_data
        ########################
        self.element = element
        self.ion_stage = ion_stage
        self.ionZ = ionZ
        self.atomicWeight = atomicWeight
        self.element_abund = element_abund
        self.ioneq_logtemp = eq_logtemp
        self.ioneq_frac    = eq_frac
        self.ioneq_logfrac = eq_logfrac
        self.ioneq_yderiv2 = yderiv2
        self.qnj = qnj
        ########################
        self.see_neq    = see_neq
        self.see_index  = see_index
        self.see_lev    = see_lev
        self.see_k      = see_k
        self.see_dk     = see_dk
        self.weight     = weight
        ########################
        self.scups_data = scups_data
        self.elowlev    = elowlev
        self.eupplev    = eupplev
        self.ciK        = ciK
        self.ciK_indx   = ciK_indx
        self.csK        = csK
        self.csK_indx   = csK_indx
        ########################
        self.splups_data = splups_data
        self.plowlev     = plowlev
        self.pupplev     = pupplev
        self.ciKp        = ciKp
        self.ciKp_indx   = ciKp_indx
        self.csKp        = csKp
        self.csKp_indx   = csKp_indx
        ########################
        ## radiative transition info
        self.rlowlev    = rlowlev
        self.rupplev    = rupplev
        self.Dcoeff     = Dcoeff
        self.Ecoeff     = Ecoeff
        self.geff       = geff
        self.alamb      = alamb
        self.wv_air     = wv_air
        self.a_up2low   = a_up2low
        self.b_up2low   = b_up2low
        self.b_low2up   = b_low2up
        self.tnD        = tnD
        self.tnD_indx   = tnD_indx
        self.nonD_spon  = nonD_spon
        self.tD         = tD
        self.tD_indx    = tD_indx
        self.Dmat_spon  = Dmat_spon

    def __repr__(self):
         return f&#34;&#34;&#34;pyCELP Ion class
    ---------------------
    Ion Name: {self.ion_name}
    Number of energy levels included: {self.nlevels}
    Number of SEE equations: {self.see_neq}
    Number of Radiative Transitions: {len(self.alamb)}
    Ionization Equilbrium Filename: {self.ioneq_data[&#39;filename&#39;]}&#34;&#34;&#34;

    def get_maxtemp(self):
        &#34;&#34;&#34; Returns the temperature at maximum ionization fraction in Kelvin &#34;&#34;&#34;
        logt = np.linspace(5,7,50)
        eq_frac_int  = 10.**(util.spintarr(logt,self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        logt_max = logt[np.argmax(eq_frac_int)]
        return 10.**logt_max

    def calc_rho_sym(self,edens,etemp,height,thetab,include_limbdark = True,
                    include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) for the
        case of a cylindrically symmetric radiation field.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        height : float (units: fraction of a solar radius)
            Height above the solar photosphere
        thetab : float (units: degrees)
            Inclination angle of the magnetic field relative to the solar
            vertical (i.e. 0 == vertical, 90 = horizontal)

        Other Parameters
        ----------
        include_limbdark:  bool (default: True)
            Flag to include limb darkening in the radiation field calculation
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;
        thetab = np.deg2rad(thetab)
        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.etemp = etemp 
        self.pdens = pdens
        self.toth  = toth
        self.thetab_rad = thetab

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens)

        self.radj    = util.rad_field_bframe(self.alamb,thetab,height,include_limbdark = include_limbdark)

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_rho_radj(self,edens,etemp,radj,include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) in the case
        that the radiation field tensor components are given as a input.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        radj : float,nparray (shape is (3, number of radiative transitions))
            Radiation field tensor components (QK = 00,01,02) for all
            radiative transitions in the ion

        Other Parameters
        ----------
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;

        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.etemp = etemp 
        self.pdens = pdens
        self.toth  = toth

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens) 
        
        self.radj    = radj

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_ecoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        ecmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            ecmat_std[n,:] = self.ecmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return ecmat_std

    def calc_pcoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        pcmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            pcmat_std[n,:] = self.pcmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return pcmat_std

    def calc_dipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        Dmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            Dmat_std[n,:] = Dmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return Dmat_std

    def calc_nonDipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        nonDmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            nonDmat_std[n,:] = nonDmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return nonDmat_std

    def calc_rad_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        DD = nonDmat + Dmat
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        radmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            radmat_std[n,:] = DD[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return radmat_std
    
    def show_lines(self,nlines=None,start=0):
        &#34;&#34;&#34; prints out information for the radiative transitions

        Parameters
        ----------
        nlines : int (default = None)
            The number of spectral lines to print
        start:  int (default = 0)
            Starting index of lines printed.
            Lines are ordered roughly by energy level indices
        &#34;&#34;&#34;

        if (nlines == None):
            nlines = len(self.alamb)
            start = 0

        assert start &gt;= 0
        assert start &lt;= len(self.alamb)
        assert nlines &lt;= len(self.alamb)
        print(&#39; Index -- WV_VAC [A] -- WV_AIR [A] -- TRANSITION&#39;)
        for ln in range(start,start+nlines):
            wv = np.round(self.alamb[ln],3)
            wvair = np.round(self.wv_air[ln],3)
            upplev,lowlev = self.rupplev[ln],self.rlowlev[ln]
            print(ln, wv,wvair, self.elvl_data[&#39;full_level&#39;][upplev], &#39; --&gt; &#39;, self.elvl_data[&#39;full_level&#39;][lowlev])

    def energy_levels_to_dataframe(self): 
        &#34;&#34;&#34; Converts Chianti Energy Level information to a Pandas dataframe &#34;&#34;&#34;
        
        try: 
            import pandas as pd
        except: 
            print(&#39; To convert Energy Level Information to dataframe requires pandas package to be installed&#39;)
            
        energy_units = self.elvl_data[&#39;energy_units&#39;]
        
        d = {&#39;Index&#39;      : self.elvl_data[&#39;index&#39;], 
             &#39;Ion_name&#39;   : np.repeat(self.ion_name,self.nlevels),
             &#39;Ion_z&#39;      : np.repeat(self.elvl_data[&#39;ion_z&#39;],self.nlevels),
             &#39;Config&#39;     : self.elvl_data[&#39;conf&#39;], 
             &#39;Conf Idx&#39; : self.elvl_data[&#39;conf_index&#39;],
             &#39;Term&#39;       : self.elvl_data[&#39;term&#39;], 
             &#39;Level&#39;      : self.elvl_data[&#39;level&#39;], 
             &#39;Full Level&#39; : self.elvl_data[&#39;full_level&#39;],
             &#39;Spin Mult&#39;  : self.elvl_data[&#39;mult&#39;],
             &#39;S&#39;       : self.elvl_data[&#39;s&#39;],
             &#39;L&#39;       : self.elvl_data[&#39;l&#39;],
             &#39;Orbital&#39; : self.elvl_data[&#39;l_sym&#39;],
             &#39;J&#39;      : self.elvl_data[&#39;j&#39;],
             &#39;Lande g&#39; : self.landeg,
             &#39;Parity&#39; : self.elvl_data[&#39;parity&#39;],
             &#39;Parity Str&#39; : self.elvl_data[&#39;parity_str&#39;],
             &#39;Stat. Weight&#39;  : self.elvl_data[&#39;weight&#39;],
             &#39;Obs Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;obs_energy&#39;],
             &#39;Theory Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;theory_energy&#39;],
             &#39;Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;energy&#39;]}
 
        return pd.DataFrame(data=d)
    
    
    def rad_transitions_to_dataframe(self): 
        &#34;&#34;&#34; Converts Radiative Transition information to a Pandas dataframe &#34;&#34;&#34;
        
        try: 
            import pandas as pd
        except: 
            print(&#39; To convert Radiative Transition Information to dataframe requires pandas package to be installed&#39;)
            
        d = {&#39;Lambda Vac [A]&#39; : self.alamb,
             &#39;Lambda Air [A]&#39; : self.wv_air,
             &#39;UppLev Idx&#39;     : self.rupplev +1,
             &#39;LowLev Idx&#39;     : self.rlowlev +1,
             &#39;Upper Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rupplev],
             &#39;Lower Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rlowlev],
             &#39;geff [LS]&#39;      : self.geff, 
             &#39;D coeff&#39;        : self.Dcoeff,
             &#39;E coeff&#39;        : self.Ecoeff,
             &#39;Einstein A&#39;     : self.a_up2low} 
        
        return pd.DataFrame(data=d)
    
    def get_emissionLine(self,wv_air): 
        &#34;&#34;&#34; Returns an instance of the emissionLine class that contains all information needed to synthesize the line 
        
        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line (approximate - only needs to be close) 
        &#34;&#34;&#34;
        line = emissionLine(self,wv_air)
        return line </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycelp.ion.Ion"><code class="flex name class">
<span>class <span class="ident">Ion</span></span>
<span>(</span><span>ion_name, nlevels=None, ioneqFile=None, abundFile=None, all_ks=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The ion object is the primary class used by pycelp for calculations of the
polarized emission for a particular transition. Upon initialization, an Ion
object loads all necessary atomic data from the CHIANTI database and
pre-calculates all pre-factors and static terms of the statistical
equilibrium rate equations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ion_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of ion (e.g., 'fe_13')</dd>
<dt><strong><code>nlevels</code></strong> :&ensp;<code>int (default = None)</code></dt>
<dd>Number of energy levels to include (default is all)</dd>
<dt><strong><code>ioneqFile</code></strong> :&ensp;<code>str (default = None)</code></dt>
<dd>Ionization equilibrium filename (defaults to Chianti default file)</dd>
<dt><strong><code>abundFile</code></strong> :&ensp;<code>str (default = None)</code></dt>
<dd>Abundance filename (defaults to sun_photospheric_2009_asplund.abund)</dd>
<dt><strong><code>all_ks</code></strong> :&ensp;<code>bool (default = False)</code></dt>
<dd>Flag to include all multipole order Ks in the calculation
The default is to include only the even values of K for the no
coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.</dd>
</dl>
<h2 id="references">References</h2>
<p>Egidio Landi Degl’innocenti and Marco Landolfi (2004)
"Polarization in Spectral Lines"
<a href="https://link.springer.com/book/10.1007/1-4020-2415-0">https://link.springer.com/book/10.1007/1-4020-2415-0</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ion:
    &#34;&#34;&#34;
    The ion object is the primary class used by pycelp for calculations of the
    polarized emission for a particular transition. Upon initialization, an Ion
    object loads all necessary atomic data from the CHIANTI database and
    pre-calculates all pre-factors and static terms of the statistical
    equilibrium rate equations.

    Parameters
    ----------
    ion_name : str
        Name of ion (e.g., &#39;fe_13&#39;)
    nlevels:  int (default = None)
        Number of energy levels to include (default is all)
    ioneqFile : str (default = None)
        Ionization equilibrium filename (defaults to Chianti default file)
    abundFile : str (default = None)
        Abundance filename (defaults to sun_photospheric_2009_asplund.abund)
    all_ks : bool (default = False)
        Flag to include all multipole order Ks in the calculation
        The default is to include only the even values of K for the no
        coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.

    References
    ----------
    Egidio Landi Degl’innocenti and Marco Landolfi (2004)
    &#34;Polarization in Spectral Lines&#34;
    &lt;https://link.springer.com/book/10.1007/1-4020-2415-0&gt;

    &#34;&#34;&#34;

    def __init__(self, ion_name,nlevels=None,ioneqFile=None,
                abundFile=None,all_ks = False):

        ## READ CHIANTI ATOMIC DATA
        elvl_data    = elvlcRead(ion_name)   ## ENERGY LEVEL DATA
        wgfa_data    = wgfaRead(ion_name)    ## RADIATIVE TRANSITION DATA
        scups_data   = scupsRead(ion_name)   ## ELECTRON COLLISIONAL DATA
        splups_data  = splupsRead(ion_name)  ## PROTON COLLISIONAL DATA
        abund_data   = abundRead(&#39;temp&#39;)     ## not selectable yet
        ioneq_data   = ioneqRead(&#39;temp&#39;)     ## not selectable yet

        ### REDUCE NUMBER OF CONSIDERED LEVELS
        if nlevels != None:
            elvl_data  = limit_levels(elvl_data,nlevels,type = &#39;elvl&#39;)
            wgfa_data  = limit_levels(wgfa_data,nlevels,type = &#39;wgfa&#39;)
            scups_data = limit_levels(scups_data,nlevels,type = &#39;scups&#39;)
            splups_data = limit_levels(splups_data,nlevels,type = &#39;splups&#39;)

        nlevels     = len(elvl_data[&#39;energy&#39;])

        ### DERIVE NECESSARY ATOMIC PARAMETERS
        element, ion_stage = ion_name.split(&#39;_&#39;)
        ion_stage     = int(ion_stage)
        ionZ          = getIonZ(ion_name)
        atomicWeight  = getAtomicWeight(element)
        element_abund = abund_data[&#39;abund_val&#39;][np.where(abund_data[&#39;abund_z&#39;] == ionZ)][0]
        eq_logtemp    = np.copy(ioneq_data[&#39;temp&#39;])
        eq_frac       = np.copy(ioneq_data[&#39;ionfrac&#39;][:,ionZ-1,ion_stage-1]).clip(1.e-30)
        eq_logfrac    = np.log10(eq_frac)
        yderiv2       = util.new_second_derivative(eq_logtemp,eq_logfrac,1e100,1e100)
        qnj           = elvl_data[&#39;j&#39;]

        ######### SETUP INDICES OF THE SEE MATRIX AND GET WEIGHTS
        see_neq,see_index,see_lev,see_k,see_dk = util.setupSEE(qnj,all_ks=all_ks)
        weight = np.zeros(see_neq)
        weight[see_k == 0] =  np.sqrt((2.*qnj[see_lev[see_k == 0]]+1))

        ######### ELECTRON COLLISION RATE INITIALIZATION CALCULATIONS
        ## precalculate the spline interpolations
        scups_data[&#39;yd2&#39;] = getSecondDerivatives(scups_data[&#39;bt_t&#39;],scups_data[&#39;bt_upsilon&#39;],scups_data[&#39;n_t&#39;])
        ettype = util.get_eTransType(elvl_data,scups_data)
        elowlev = scups_data[&#39;lower_level_index&#39;]-1
        eupplev = scups_data[&#39;upper_level_index&#39;]-1
        print(&#39; setting up electron collision rate factors&#39;)
        ciK,ciK_indx,csK,csK_indx = setup_ecoll(elowlev,eupplev,ettype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### PROTON COLLISION RATE INITIALIZATION CALCULATIONS
        splups_data[&#39;yd2&#39;] = getSecondDerivatives(splups_data[&#39;bt_t&#39;],splups_data[&#39;bt_upsilon&#39;],splups_data[&#39;n_t&#39;])
        plowlev = splups_data[&#39;lower_level_index&#39;]-1
        pupplev = splups_data[&#39;upper_level_index&#39;]-1
        pttype = np.zeros(len(plowlev)) - 1
        print(&#39; setting up proton  collision rate factors&#39;)
        ciKp,ciKp_indx,csKp,csKp_indx = setup_ecoll(plowlev,pupplev,pttype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### RADIATIVE RATES INITIALIZATION CALCULATIONS

        rupplev = wgfa_data[&#39;upper_level_index&#39;]-1
        rlowlev = wgfa_data[&#39;lower_level_index&#39;]-1
        gup    = 2*qnj[rupplev]+1
        glo    = 2*qnj[rlowlev]+1
        alamb  = 1.e8 / (elvl_data[&#39;energy&#39;][rupplev] - elvl_data[&#39;energy&#39;][rlowlev])
        a_up2low = wgfa_data[&#39;A_einstein&#39;]
        hh = 6.626176e-27  ## ergs sec (planck&#39;s constant);
        cc = 2.99792458e10 ## cm s^-1 (speed of light)
        b_up2low = (alamb**3)/2./hh/cc/1.e24*a_up2low
        b_low2up = gup/glo*b_up2low
        nrad = len(rlowlev)

        wv_air = util.vac2air(alamb)

        ### DERIVE D and E coefficients
        ss,ll,jj = elvl_data[&#39;s&#39;],elvl_data[&#39;l&#39;],elvl_data[&#39;j&#39;]
        landeg = util.calcLande(jj,ss,ll)
        Jupp,Jlow = jj[rupplev],jj[rlowlev]
        gupp,glow = landeg[rupplev],landeg[rlowlev]
        Dcoeff = util.getDcoeff(Jupp,Jlow)
        Ecoeff = util.getEcoeff(Jupp,Jlow,gupp,glow)
        geff = 0.5*(glow+gupp) + 0.25 * (glow-gupp) * (Jlow*(Jlow+1.) - Jupp*(Jupp+1.))
        
        ## --&gt; Non-dipoles
        print(&#39; setting up non-dipole radiative rate factors&#39;)
        tnD,tnD_indx,nonD_spon= setup_nonDipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,
                                                b_up2low,see_index,see_lev,see_k,see_dk)

        ## ---&gt; Dipoles
        print(&#39; setting up dipole radiative rate factors&#39;)
        tD,tD_indx,Dmat_spon = setup_Dipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,b_up2low,see_index,see_lev,see_k,see_dk)

        #################################################
        ## put into instance information
        self.ion_name = ion_name
        self.all_ks = all_ks
        ########################
        self.nlevels = nlevels
        self.elvl_data    = elvl_data
        self.landeg       = landeg
        self.wgfa_data    = wgfa_data
        self.scups_data   = scups_data
        self.splups_data  = splups_data
        self.abund_data   = abund_data
        self.ioneq_data   = ioneq_data
        ########################
        self.element = element
        self.ion_stage = ion_stage
        self.ionZ = ionZ
        self.atomicWeight = atomicWeight
        self.element_abund = element_abund
        self.ioneq_logtemp = eq_logtemp
        self.ioneq_frac    = eq_frac
        self.ioneq_logfrac = eq_logfrac
        self.ioneq_yderiv2 = yderiv2
        self.qnj = qnj
        ########################
        self.see_neq    = see_neq
        self.see_index  = see_index
        self.see_lev    = see_lev
        self.see_k      = see_k
        self.see_dk     = see_dk
        self.weight     = weight
        ########################
        self.scups_data = scups_data
        self.elowlev    = elowlev
        self.eupplev    = eupplev
        self.ciK        = ciK
        self.ciK_indx   = ciK_indx
        self.csK        = csK
        self.csK_indx   = csK_indx
        ########################
        self.splups_data = splups_data
        self.plowlev     = plowlev
        self.pupplev     = pupplev
        self.ciKp        = ciKp
        self.ciKp_indx   = ciKp_indx
        self.csKp        = csKp
        self.csKp_indx   = csKp_indx
        ########################
        ## radiative transition info
        self.rlowlev    = rlowlev
        self.rupplev    = rupplev
        self.Dcoeff     = Dcoeff
        self.Ecoeff     = Ecoeff
        self.geff       = geff
        self.alamb      = alamb
        self.wv_air     = wv_air
        self.a_up2low   = a_up2low
        self.b_up2low   = b_up2low
        self.b_low2up   = b_low2up
        self.tnD        = tnD
        self.tnD_indx   = tnD_indx
        self.nonD_spon  = nonD_spon
        self.tD         = tD
        self.tD_indx    = tD_indx
        self.Dmat_spon  = Dmat_spon

    def __repr__(self):
         return f&#34;&#34;&#34;pyCELP Ion class
    ---------------------
    Ion Name: {self.ion_name}
    Number of energy levels included: {self.nlevels}
    Number of SEE equations: {self.see_neq}
    Number of Radiative Transitions: {len(self.alamb)}
    Ionization Equilbrium Filename: {self.ioneq_data[&#39;filename&#39;]}&#34;&#34;&#34;

    def get_maxtemp(self):
        &#34;&#34;&#34; Returns the temperature at maximum ionization fraction in Kelvin &#34;&#34;&#34;
        logt = np.linspace(5,7,50)
        eq_frac_int  = 10.**(util.spintarr(logt,self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        logt_max = logt[np.argmax(eq_frac_int)]
        return 10.**logt_max

    def calc_rho_sym(self,edens,etemp,height,thetab,include_limbdark = True,
                    include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) for the
        case of a cylindrically symmetric radiation field.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        height : float (units: fraction of a solar radius)
            Height above the solar photosphere
        thetab : float (units: degrees)
            Inclination angle of the magnetic field relative to the solar
            vertical (i.e. 0 == vertical, 90 = horizontal)

        Other Parameters
        ----------
        include_limbdark:  bool (default: True)
            Flag to include limb darkening in the radiation field calculation
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;
        thetab = np.deg2rad(thetab)
        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.etemp = etemp 
        self.pdens = pdens
        self.toth  = toth
        self.thetab_rad = thetab

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens)

        self.radj    = util.rad_field_bframe(self.alamb,thetab,height,include_limbdark = include_limbdark)

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_rho_radj(self,edens,etemp,radj,include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) in the case
        that the radiation field tensor components are given as a input.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        radj : float,nparray (shape is (3, number of radiative transitions))
            Radiation field tensor components (QK = 00,01,02) for all
            radiative transitions in the ion

        Other Parameters
        ----------
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;

        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.etemp = etemp 
        self.pdens = pdens
        self.toth  = toth

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens) 
        
        self.radj    = radj

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_ecoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        ecmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            ecmat_std[n,:] = self.ecmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return ecmat_std

    def calc_pcoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        pcmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            pcmat_std[n,:] = self.pcmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return pcmat_std

    def calc_dipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        Dmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            Dmat_std[n,:] = Dmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return Dmat_std

    def calc_nonDipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        nonDmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            nonDmat_std[n,:] = nonDmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return nonDmat_std

    def calc_rad_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        DD = nonDmat + Dmat
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        radmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            radmat_std[n,:] = DD[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return radmat_std
    
    def show_lines(self,nlines=None,start=0):
        &#34;&#34;&#34; prints out information for the radiative transitions

        Parameters
        ----------
        nlines : int (default = None)
            The number of spectral lines to print
        start:  int (default = 0)
            Starting index of lines printed.
            Lines are ordered roughly by energy level indices
        &#34;&#34;&#34;

        if (nlines == None):
            nlines = len(self.alamb)
            start = 0

        assert start &gt;= 0
        assert start &lt;= len(self.alamb)
        assert nlines &lt;= len(self.alamb)
        print(&#39; Index -- WV_VAC [A] -- WV_AIR [A] -- TRANSITION&#39;)
        for ln in range(start,start+nlines):
            wv = np.round(self.alamb[ln],3)
            wvair = np.round(self.wv_air[ln],3)
            upplev,lowlev = self.rupplev[ln],self.rlowlev[ln]
            print(ln, wv,wvair, self.elvl_data[&#39;full_level&#39;][upplev], &#39; --&gt; &#39;, self.elvl_data[&#39;full_level&#39;][lowlev])

    def energy_levels_to_dataframe(self): 
        &#34;&#34;&#34; Converts Chianti Energy Level information to a Pandas dataframe &#34;&#34;&#34;
        
        try: 
            import pandas as pd
        except: 
            print(&#39; To convert Energy Level Information to dataframe requires pandas package to be installed&#39;)
            
        energy_units = self.elvl_data[&#39;energy_units&#39;]
        
        d = {&#39;Index&#39;      : self.elvl_data[&#39;index&#39;], 
             &#39;Ion_name&#39;   : np.repeat(self.ion_name,self.nlevels),
             &#39;Ion_z&#39;      : np.repeat(self.elvl_data[&#39;ion_z&#39;],self.nlevels),
             &#39;Config&#39;     : self.elvl_data[&#39;conf&#39;], 
             &#39;Conf Idx&#39; : self.elvl_data[&#39;conf_index&#39;],
             &#39;Term&#39;       : self.elvl_data[&#39;term&#39;], 
             &#39;Level&#39;      : self.elvl_data[&#39;level&#39;], 
             &#39;Full Level&#39; : self.elvl_data[&#39;full_level&#39;],
             &#39;Spin Mult&#39;  : self.elvl_data[&#39;mult&#39;],
             &#39;S&#39;       : self.elvl_data[&#39;s&#39;],
             &#39;L&#39;       : self.elvl_data[&#39;l&#39;],
             &#39;Orbital&#39; : self.elvl_data[&#39;l_sym&#39;],
             &#39;J&#39;      : self.elvl_data[&#39;j&#39;],
             &#39;Lande g&#39; : self.landeg,
             &#39;Parity&#39; : self.elvl_data[&#39;parity&#39;],
             &#39;Parity Str&#39; : self.elvl_data[&#39;parity_str&#39;],
             &#39;Stat. Weight&#39;  : self.elvl_data[&#39;weight&#39;],
             &#39;Obs Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;obs_energy&#39;],
             &#39;Theory Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;theory_energy&#39;],
             &#39;Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;energy&#39;]}
 
        return pd.DataFrame(data=d)
    
    
    def rad_transitions_to_dataframe(self): 
        &#34;&#34;&#34; Converts Radiative Transition information to a Pandas dataframe &#34;&#34;&#34;
        
        try: 
            import pandas as pd
        except: 
            print(&#39; To convert Radiative Transition Information to dataframe requires pandas package to be installed&#39;)
            
        d = {&#39;Lambda Vac [A]&#39; : self.alamb,
             &#39;Lambda Air [A]&#39; : self.wv_air,
             &#39;UppLev Idx&#39;     : self.rupplev +1,
             &#39;LowLev Idx&#39;     : self.rlowlev +1,
             &#39;Upper Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rupplev],
             &#39;Lower Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rlowlev],
             &#39;geff [LS]&#39;      : self.geff, 
             &#39;D coeff&#39;        : self.Dcoeff,
             &#39;E coeff&#39;        : self.Ecoeff,
             &#39;Einstein A&#39;     : self.a_up2low} 
        
        return pd.DataFrame(data=d)
    
    def get_emissionLine(self,wv_air): 
        &#34;&#34;&#34; Returns an instance of the emissionLine class that contains all information needed to synthesize the line 
        
        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line (approximate - only needs to be close) 
        &#34;&#34;&#34;
        line = emissionLine(self,wv_air)
        return line </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycelp.ion.Ion.calc_dipole_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_dipole_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dipole_matrix_standard(self,ht,thetab):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    Dmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        Dmat_std[n,:] = Dmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return Dmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.calc_ecoll_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_ecoll_matrix_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_ecoll_matrix_standard(self):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    ecmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        ecmat_std[n,:] = self.ecmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return ecmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.calc_nonDipole_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_nonDipole_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_nonDipole_matrix_standard(self,ht,thetab):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    nonDmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        nonDmat_std[n,:] = nonDmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return nonDmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.calc_pcoll_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_pcoll_matrix_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_pcoll_matrix_standard(self):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    pcmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        pcmat_std[n,:] = self.pcmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return pcmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.calc_rad_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_rad_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rad_matrix_standard(self,ht,thetab):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
    DD = nonDmat + Dmat
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    radmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        radmat_std[n,:] = DD[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return radmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.calc_rho_radj"><code class="name flex">
<span>def <span class="ident">calc_rho_radj</span></span>(<span>self, edens, etemp, radj, include_protons=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the elements of the atomic density matrix (rho) in the case
that the radiation field tensor components are given as a input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edens</code></strong> :&ensp;<code>float (units: cm^-3)</code></dt>
<dd>Electron density (e.g., 1e8)</dd>
<dt><strong><code>etemp</code></strong> :&ensp;<code>float (units: K)</code></dt>
<dd>Electron temperature (e.g., 1.e6)</dd>
<dt><strong><code>radj</code></strong> :&ensp;<code>float,nparray (shape is (3, number</code> of <code>radiative transitions))</code></dt>
<dd>Radiation field tensor components (QK = 00,01,02) for all
radiative transitions in the ion</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_protons</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flat to include protons in the collisional rates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rho_radj(self,edens,etemp,radj,include_protons = True):
    &#34;&#34;&#34;
    Calculates the elements of the atomic density matrix (rho) in the case
    that the radiation field tensor components are given as a input.

    Parameters
    ----------
    edens : float (units: cm^-3)
        Electron density (e.g., 1e8)
    etemp : float (units: K)
        Electron temperature (e.g., 1.e6)
    radj : float,nparray (shape is (3, number of radiative transitions))
        Radiation field tensor components (QK = 00,01,02) for all
        radiative transitions in the ion

    Other Parameters
    ----------
    include_protons:  bool (default: True)
        Flat to include protons in the collisional rates

    &#34;&#34;&#34;

    ptemp = etemp
    toth  = 0.85*edens
    pdens = 1.*toth
    if not include_protons:
        pdens = 0.

    self.edens = edens
    self.etemp = etemp 
    self.pdens = pdens
    self.toth  = toth

    eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
    totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

    erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                      self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                      self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                      self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                      etemp,edens)

    prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                      self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                      self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                      self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                      ptemp,pdens) 
    
    self.radj    = radj

    ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                             erates_up,erates_down,self.see_neq)
    pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                             prates_up,prates_down,self.see_neq)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

    self.collmat = ecmat + pcmat
    self.radmat = Dmat + nonDmat
    self.see_matrix = self.collmat + self.radmat

    rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

    self.rho = rho
    self.totn = totn</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.calc_rho_sym"><code class="name flex">
<span>def <span class="ident">calc_rho_sym</span></span>(<span>self, edens, etemp, height, thetab, include_limbdark=True, include_protons=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the elements of the atomic density matrix (rho) for the
case of a cylindrically symmetric radiation field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edens</code></strong> :&ensp;<code>float (units: cm^-3)</code></dt>
<dd>Electron density (e.g., 1e8)</dd>
<dt><strong><code>etemp</code></strong> :&ensp;<code>float (units: K)</code></dt>
<dd>Electron temperature (e.g., 1.e6)</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float (units: fraction</code> of <code>a solar radius)</code></dt>
<dd>Height above the solar photosphere</dd>
<dt><strong><code>thetab</code></strong> :&ensp;<code>float (units: degrees)</code></dt>
<dd>Inclination angle of the magnetic field relative to the solar
vertical (i.e. 0 == vertical, 90 = horizontal)</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_limbdark</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flag to include limb darkening in the radiation field calculation</dd>
<dt><strong><code>include_protons</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flat to include protons in the collisional rates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rho_sym(self,edens,etemp,height,thetab,include_limbdark = True,
                include_protons = True):
    &#34;&#34;&#34;
    Calculates the elements of the atomic density matrix (rho) for the
    case of a cylindrically symmetric radiation field.

    Parameters
    ----------
    edens : float (units: cm^-3)
        Electron density (e.g., 1e8)
    etemp : float (units: K)
        Electron temperature (e.g., 1.e6)
    height : float (units: fraction of a solar radius)
        Height above the solar photosphere
    thetab : float (units: degrees)
        Inclination angle of the magnetic field relative to the solar
        vertical (i.e. 0 == vertical, 90 = horizontal)

    Other Parameters
    ----------
    include_limbdark:  bool (default: True)
        Flag to include limb darkening in the radiation field calculation
    include_protons:  bool (default: True)
        Flat to include protons in the collisional rates

    &#34;&#34;&#34;
    thetab = np.deg2rad(thetab)
    ptemp = etemp
    toth  = 0.85*edens
    pdens = 1.*toth
    if not include_protons:
        pdens = 0.

    self.edens = edens
    self.etemp = etemp 
    self.pdens = pdens
    self.toth  = toth
    self.thetab_rad = thetab

    eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
    totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

    erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                      self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                      self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                      self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                      etemp,edens)

    prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                      self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                      self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                      self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                      ptemp,pdens)

    self.radj    = util.rad_field_bframe(self.alamb,thetab,height,include_limbdark = include_limbdark)

    ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                             erates_up,erates_down,self.see_neq)
    pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                             prates_up,prates_down,self.see_neq)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

    self.collmat = ecmat + pcmat
    self.radmat = Dmat + nonDmat
    self.see_matrix = self.collmat + self.radmat

    rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

    self.rho = rho
    self.totn = totn</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.energy_levels_to_dataframe"><code class="name flex">
<span>def <span class="ident">energy_levels_to_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Chianti Energy Level information to a Pandas dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def energy_levels_to_dataframe(self): 
    &#34;&#34;&#34; Converts Chianti Energy Level information to a Pandas dataframe &#34;&#34;&#34;
    
    try: 
        import pandas as pd
    except: 
        print(&#39; To convert Energy Level Information to dataframe requires pandas package to be installed&#39;)
        
    energy_units = self.elvl_data[&#39;energy_units&#39;]
    
    d = {&#39;Index&#39;      : self.elvl_data[&#39;index&#39;], 
         &#39;Ion_name&#39;   : np.repeat(self.ion_name,self.nlevels),
         &#39;Ion_z&#39;      : np.repeat(self.elvl_data[&#39;ion_z&#39;],self.nlevels),
         &#39;Config&#39;     : self.elvl_data[&#39;conf&#39;], 
         &#39;Conf Idx&#39; : self.elvl_data[&#39;conf_index&#39;],
         &#39;Term&#39;       : self.elvl_data[&#39;term&#39;], 
         &#39;Level&#39;      : self.elvl_data[&#39;level&#39;], 
         &#39;Full Level&#39; : self.elvl_data[&#39;full_level&#39;],
         &#39;Spin Mult&#39;  : self.elvl_data[&#39;mult&#39;],
         &#39;S&#39;       : self.elvl_data[&#39;s&#39;],
         &#39;L&#39;       : self.elvl_data[&#39;l&#39;],
         &#39;Orbital&#39; : self.elvl_data[&#39;l_sym&#39;],
         &#39;J&#39;      : self.elvl_data[&#39;j&#39;],
         &#39;Lande g&#39; : self.landeg,
         &#39;Parity&#39; : self.elvl_data[&#39;parity&#39;],
         &#39;Parity Str&#39; : self.elvl_data[&#39;parity_str&#39;],
         &#39;Stat. Weight&#39;  : self.elvl_data[&#39;weight&#39;],
         &#39;Obs Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;obs_energy&#39;],
         &#39;Theory Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;theory_energy&#39;],
         &#39;Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;energy&#39;]}

    return pd.DataFrame(data=d)</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.get_emissionLine"><code class="name flex">
<span>def <span class="ident">get_emissionLine</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an instance of the emissionLine class that contains all information needed to synthesize the line </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line (approximate - only needs to be close)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_emissionLine(self,wv_air): 
    &#34;&#34;&#34; Returns an instance of the emissionLine class that contains all information needed to synthesize the line 
    
    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line (approximate - only needs to be close) 
    &#34;&#34;&#34;
    line = emissionLine(self,wv_air)
    return line </code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.get_maxtemp"><code class="name flex">
<span>def <span class="ident">get_maxtemp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the temperature at maximum ionization fraction in Kelvin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_maxtemp(self):
    &#34;&#34;&#34; Returns the temperature at maximum ionization fraction in Kelvin &#34;&#34;&#34;
    logt = np.linspace(5,7,50)
    eq_frac_int  = 10.**(util.spintarr(logt,self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
    logt_max = logt[np.argmax(eq_frac_int)]
    return 10.**logt_max</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.rad_transitions_to_dataframe"><code class="name flex">
<span>def <span class="ident">rad_transitions_to_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Radiative Transition information to a Pandas dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rad_transitions_to_dataframe(self): 
    &#34;&#34;&#34; Converts Radiative Transition information to a Pandas dataframe &#34;&#34;&#34;
    
    try: 
        import pandas as pd
    except: 
        print(&#39; To convert Radiative Transition Information to dataframe requires pandas package to be installed&#39;)
        
    d = {&#39;Lambda Vac [A]&#39; : self.alamb,
         &#39;Lambda Air [A]&#39; : self.wv_air,
         &#39;UppLev Idx&#39;     : self.rupplev +1,
         &#39;LowLev Idx&#39;     : self.rlowlev +1,
         &#39;Upper Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rupplev],
         &#39;Lower Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rlowlev],
         &#39;geff [LS]&#39;      : self.geff, 
         &#39;D coeff&#39;        : self.Dcoeff,
         &#39;E coeff&#39;        : self.Ecoeff,
         &#39;Einstein A&#39;     : self.a_up2low} 
    
    return pd.DataFrame(data=d)</code></pre>
</details>
</dd>
<dt id="pycelp.ion.Ion.show_lines"><code class="name flex">
<span>def <span class="ident">show_lines</span></span>(<span>self, nlines=None, start=0)</span>
</code></dt>
<dd>
<div class="desc"><p>prints out information for the radiative transitions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nlines</code></strong> :&ensp;<code>int (default = None)</code></dt>
<dd>The number of spectral lines to print</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>int (default = 0)</code></dt>
<dd>Starting index of lines printed.
Lines are ordered roughly by energy level indices</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_lines(self,nlines=None,start=0):
    &#34;&#34;&#34; prints out information for the radiative transitions

    Parameters
    ----------
    nlines : int (default = None)
        The number of spectral lines to print
    start:  int (default = 0)
        Starting index of lines printed.
        Lines are ordered roughly by energy level indices
    &#34;&#34;&#34;

    if (nlines == None):
        nlines = len(self.alamb)
        start = 0

    assert start &gt;= 0
    assert start &lt;= len(self.alamb)
    assert nlines &lt;= len(self.alamb)
    print(&#39; Index -- WV_VAC [A] -- WV_AIR [A] -- TRANSITION&#39;)
    for ln in range(start,start+nlines):
        wv = np.round(self.alamb[ln],3)
        wvair = np.round(self.wv_air[ln],3)
        upplev,lowlev = self.rupplev[ln],self.rlowlev[ln]
        print(ln, wv,wvair, self.elvl_data[&#39;full_level&#39;][upplev], &#39; --&gt; &#39;, self.elvl_data[&#39;full_level&#39;][lowlev])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycelp" href="index.html">pycelp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycelp.ion.Ion" href="#pycelp.ion.Ion">Ion</a></code></h4>
<ul class="">
<li><code><a title="pycelp.ion.Ion.calc_dipole_matrix_standard" href="#pycelp.ion.Ion.calc_dipole_matrix_standard">calc_dipole_matrix_standard</a></code></li>
<li><code><a title="pycelp.ion.Ion.calc_ecoll_matrix_standard" href="#pycelp.ion.Ion.calc_ecoll_matrix_standard">calc_ecoll_matrix_standard</a></code></li>
<li><code><a title="pycelp.ion.Ion.calc_nonDipole_matrix_standard" href="#pycelp.ion.Ion.calc_nonDipole_matrix_standard">calc_nonDipole_matrix_standard</a></code></li>
<li><code><a title="pycelp.ion.Ion.calc_pcoll_matrix_standard" href="#pycelp.ion.Ion.calc_pcoll_matrix_standard">calc_pcoll_matrix_standard</a></code></li>
<li><code><a title="pycelp.ion.Ion.calc_rad_matrix_standard" href="#pycelp.ion.Ion.calc_rad_matrix_standard">calc_rad_matrix_standard</a></code></li>
<li><code><a title="pycelp.ion.Ion.calc_rho_radj" href="#pycelp.ion.Ion.calc_rho_radj">calc_rho_radj</a></code></li>
<li><code><a title="pycelp.ion.Ion.calc_rho_sym" href="#pycelp.ion.Ion.calc_rho_sym">calc_rho_sym</a></code></li>
<li><code><a title="pycelp.ion.Ion.energy_levels_to_dataframe" href="#pycelp.ion.Ion.energy_levels_to_dataframe">energy_levels_to_dataframe</a></code></li>
<li><code><a title="pycelp.ion.Ion.get_emissionLine" href="#pycelp.ion.Ion.get_emissionLine">get_emissionLine</a></code></li>
<li><code><a title="pycelp.ion.Ion.get_maxtemp" href="#pycelp.ion.Ion.get_maxtemp">get_maxtemp</a></code></li>
<li><code><a title="pycelp.ion.Ion.rad_transitions_to_dataframe" href="#pycelp.ion.Ion.rad_transitions_to_dataframe">rad_transitions_to_dataframe</a></code></li>
<li><code><a title="pycelp.ion.Ion.show_lines" href="#pycelp.ion.Ion.show_lines">show_lines</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>